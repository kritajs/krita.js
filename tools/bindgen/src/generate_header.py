from cxxheaderparser.simple import ClassScope, ParsedData
from cxxheaderparser.types import PQName, DecoratedType

from utils import GENERATED_FOLDER_PATH, write_file

INDENT = "    "

# ==================================================================================

def Template(
    includes: str,
    forward_decls: str,
    classes: str,
) -> str:
    return f"""// This file is automatically generated by bindgen. DO NOT EDIT.

// Some libkis classes depend on QtGlobal typedefs so we just include it in every header for convenience
#include <QtGlobal>
// Contains common Qt includes and libkis forward declarations
#include "libkis.h"
{includes}

{forward_decls}

{classes}
"""

# ==================================================================================

def Class(c: ClassScope) -> tuple[str, set[str], set[str]]:
    base_class_includes: set[str] = set()
    forward_decls: set[str] = set()

    # Extract base classes
    bases: list[str] = []
    for base in c.class_decl.bases:
        base_name = base.typename.format()
        # If it's a base class, then we MUST add its #include. Base classes cannot be forward declared.
        base_class_includes.add(base_name)
        bases.append(base.access + " " + base_name)

    # Construct class declaration
    class_decl = c.class_decl.typename.format()
    if (len(bases)):
        class_decl += f" : {', '.join(bases)}"

    # Extract methods. Skip private methods.
    public_methods: list[str] = []
    protected_methods: list[str] = []
    for method in c.methods:
        # Skip constructors, destructors and operator overloads
        if method.constructor or method.destructor or method.operator is not None:
            continue

        return_type = method.return_type.format()
        name = method.name.format()
        params = ", ".join(map(lambda param: param.format(), method.parameters))
        method_decl = f"{INDENT}{return_type} {name}({params})"
        if method.const:
            method_decl += " const"
        method_decl += ";"

        if method.access == "public":
            public_methods.append(method_decl)
        elif method.access == 'protected':
            protected_methods.append(method_decl)

    public = "\n".join(public_methods)
    protected = "\n".join(protected_methods)

    output = f"""{class_decl}
{{
public:
{public}

{"protected:" if len(protected_methods) else ""}
{protected}
}}
"""

    return (output, base_class_includes, forward_decls)


# ==================================================================================

def generate_header(data: ParsedData) -> str:
    # Keep any existing forward declarations
    forward_decls: set[str] = set()
    for forward_decl in data.namespace.forward_decls:
        forward_decls.add(forward_decl.typename.format())

    # Parse classes
    classes: list[str] = []
    base_class_includes: set[str] = set()
    for c in data.namespace.classes:
        (output, _base_class_includes, _forward_decls) = Class(c)
        base_class_includes = _base_class_includes
        forward_decls = forward_decls.union(_forward_decls)
        classes.append(output)

    # Format includes. Note that we only add includes for base classes.
    # Everything else can be forward declared.
    includes: set[str] = set()
    for include in base_class_includes:
        # Use angle brackets for Qt includes
        if include.startswith("Q"):
            includes.add(f"#include <{include}>")
        else:
            includes.add(f"#include \"{include}.h\"")


    return Template(
        "\n".join(includes),
        "\n".join(map(lambda name: f"{name};", forward_decls)),
        "\n".join(classes)
    )

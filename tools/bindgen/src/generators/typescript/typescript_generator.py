import glob
import re
from cxxheaderparser.simple import ParsedData
from pathlib import Path

from generator import Generator
from .ts_class import create_ts_ready_class, TS_Ready_Class
from utils import write_file

# c++ type: [ts type, path to import from if any]
type_matching_dict = {
    "qreal":        ["number",  ""],
    "bool":         ["boolean", ""],
    "void":         ["void",    ""],
    "qint8":        ["number",  ""],
    "qint16":       ["number",  ""],
    "qint32":       ["number",  ""],
    "qint64":       ["number",  ""],
    "qintptr":      ["number",  ""],
    "qlonglong":    ["number",  ""],
    "qptrdiff":     ["number",  ""],
    "qsizetype":    ["number",  ""],
    "quint8" :      ["number",  ""],
    "quint16":      ["number",  ""],
    "quint32":      ["number",  ""],
    "quint64":      ["number",  ""],
    "quintptr":     ["number",  ""],
    "qulonglong":   ["number",  ""],
    "uchar":        ["string",  ""],
    "uint":         ["number",  ""],
    "ulong":        ["number",  ""],
    "ushort":       ["number",  ""],
    "int":          ["number",  ""],
    "long":         ["number",  ""],
    "float":        ["number",  ""],
    "double":       ["number",  ""]
}

# ==================================================================================

# logic for import is to search through the same parent folder to see if that file exists
# if it does exist, add that file reference statement with the path
# we will ignore all includes for now

def Template(
    ts_class: TS_Ready_Class,
    import_statements: str,
) -> str:

    return """// This file is automatically generated by bindgen. DO NOT EDIT.

{0}

export as namespace {1}

export = {2}

{3}
""".format(import_statements, ts_class.name, ts_class.name, ts_class)

# ==================================================================================
# Add mapping between types:
# existing js types - number, string, boolean
# if there is no matching type, check the rest of the files to see if you can find an export with the same name
# ==================================================================================

class TypeScriptGenerator(Generator):
    def get_file_paths(self, krita_dir: Path) -> list[str]:
        headers = glob.glob("libs/libkis/*.h", root_dir=str(krita_dir))
        ignore = [
            # Only contains forward declarations
            "libkis.h",
            # Not used by anything
            "LibKisUtils.h",
            # Don't think we need to expose this to JS.
            # It also depends on boost and other non-libkis headers
            "PresetChooser.h"
        ]
        headers = list(filter(lambda h: Path(h).name not in ignore, headers))

        for header in headers:
            class_type = Path(header).stem
            type_matching_dict[class_type] = [class_type, class_type]

        return headers

    def process(self, file_path: Path, output_dir: Path, data: ParsedData):
        print(f"""Generating TypeScript declaration file for {file_path.name}...""")
        import_statements: set[str] = set()

        ts_class = create_ts_ready_class(data.namespace.classes[0], file_path.name)

        def update_type_for_import(value_to_update: str):
            valid_replacement = type_matching_dict[value_to_update]
            value_to_update = valid_replacement[0]
            if (valid_replacement[1] != "" and value_to_update != ts_class.name):
                import_statements.add(f"import {value_to_update} from \"./{value_to_update}\";")
            return value_to_update

        for method in ts_class.methods:
            # check the type of the param
            for param in method.params:
                # check if it's a case where a class is buried within a <> tag
                # split the parameter into parts -> main type and inner type
                main_type = param.type
                sub_type = ""
                matching_param_sub_type = re.search("(<\w+>)", main_type)

                if (matching_param_sub_type != None):
                    main_type = main_type.replace(matching_param_sub_type.group(0), "")
                    sub_type = matching_param_sub_type.group(0).replace("<", "").replace(">", "")
                    if sub_type in type_matching_dict:
                        sub_type = update_type_for_import(sub_type)

                if main_type in type_matching_dict:
                    main_type = update_type_for_import(main_type)
                
                # replace param.type altogether
                param.type = main_type if sub_type == "" else f"{main_type}<{sub_type}>"
            
            # ====================================================================================================
            # check the type of the return type
            main_return_type = method.return_type
            sub_return_type = ""
            match_sub_return_type = re.search("(<\w+>)", main_return_type)

            if (match_sub_return_type != None):
                main_return_type = main_return_type.replace(match_sub_return_type.group(0), "")
                sub_return_type = match_sub_return_type.group(0).replace("<", "").replace(">", "")
                if (sub_return_type in type_matching_dict):
                    sub_return_type = update_type_for_import(sub_return_type)

            if main_return_type in type_matching_dict:
                main_return_type = update_type_for_import(main_return_type)
            
            method.return_type = main_return_type if sub_return_type == "" else f"{main_return_type}<{sub_return_type}>"

        output = Template(ts_class, "\n".join(list(import_statements)))
        write_file(output_dir / (file_path.stem + ".d.ts"), output)

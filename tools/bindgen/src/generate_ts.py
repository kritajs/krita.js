from cxxheaderparser.simple import ClassScope, ParsedData
from TS_Class import TS_Ready_Class
import re

# ==================================================================================

# logic for import is to search through the same parent folder to see if that file exists
# if it does exist, add that file reference statement with the path
# we will ignore all includes for now

def Template(
    ts_class: TS_Ready_Class,
    import_statements: str,
) -> str:

    return f"""// This file is automatically generated by bindgen. DO NOT EDIT.

// Some libkis classes depend on QtGlobal typedefs so we just include it in every header for convenience
// All includes are currently being ignored

// Instead of determining which forward declarations we need on a per-file basis, just forward declare
// everything we might need.

{import_statements}

export as namespace {ts_class.name}

export = {ts_class.name}

{ts_class}
"""

# ==================================================================================
# Add mapping between types:
# existing js types - number, string, boolean
# if there is no matching type, check the rest of the files to see if you can find an export with the same name
# ==================================================================================

def generate_ts(data: TS_Ready_Class, type_matching_dict: dict[str, list[str]]) -> str:
    import_statements : set[str] = set()

    for method in data.methods:
        # check the type of the param
        for param in method.params:
            main_type: str = param.type
            sub_type: str = ""
            # check if it's a case where a class is buried within a <> tag
            # split the parameter into parts -> main type and inner type
            m = re.search("(<\w+>)", main_type)
            if (m != None):
                # remove m from main_type
                main_type = main_type.replace(m.group(0), "")
                # replace sub type
                sub_type = (m.group(0).replace("<", "").replace(">", ""))
                if sub_type in type_matching_dict:
                    valid_replacement = type_matching_dict[sub_type]
                    sub_type = valid_replacement[0]
                    if (valid_replacement[1] != "" and sub_type != data.name):
                        import_statements.add(f"import {sub_type} from \"./{sub_type}\";")

            if main_type in type_matching_dict:
                valid_replacement = type_matching_dict[main_type]

                main_type = valid_replacement[0]
                if (valid_replacement[1] != "" and main_type != data.name): # matching_entry[1] is the location of the file to import from
                    import_statements.add(f"import {main_type} from \"./{main_type}\";")
            
            # replace param.type altogether
            param.type = main_type if sub_type == "" else f"{main_type}<{sub_type}>"
    
        # check the type of the return type
        if method.return_type in type_matching_dict:
            matching_entry = type_matching_dict[method.return_type]

            method.return_type = matching_entry[0]
            if (matching_entry[1] != "" and method.return_type != data.name): # matching_entry[1] is the location of the file to import from
                import_statements.add(f"import {method.return_type} from \"./{method.return_type}\";")

    return Template(data, "\n".join(list(import_statements)))

from cxxheaderparser.simple import ClassScope, ParsedData
from TS_Class import TS_Ready_Class
import re

# ==================================================================================

# logic for import is to search through the same parent folder to see if that file exists
# if it does exist, add that file reference statement with the path
# we will ignore all includes for now

def Template(
    ts_class: TS_Ready_Class,
    import_statements: str,
) -> str:

    return f"""// This file is automatically generated by bindgen. DO NOT EDIT.

// Some libkis classes depend on QtGlobal typedefs so we just include it in every header for convenience
// All includes are currently being ignored

// Instead of determining which forward declarations we need on a per-file basis, just forward declare
// everything we might need.

{import_statements}

export as namespace {ts_class.name}

export = {ts_class.name}

{ts_class}
"""

# ==================================================================================
# Add mapping between types:
# existing js types - number, string, boolean
# if there is no matching type, check the rest of the files to see if you can find an export with the same name
# ==================================================================================

def generate_ts(data: TS_Ready_Class, type_matching_dict: dict[str, list[str]]) -> str:
    import_statements : set[str] = set()

    def update_type_for_import(value_to_update: str):
        valid_replacement = type_matching_dict[value_to_update]
        value_to_update = valid_replacement[0]
        if (valid_replacement[1] != "" and value_to_update != data.name):
            import_statements.add(f"import {value_to_update} from \"./{value_to_update}\";")
        return value_to_update

    for method in data.methods:
        # check the type of the param
        for param in method.params:
            # check if it's a case where a class is buried within a <> tag
            # split the parameter into parts -> main type and inner type
            main_type = param.type
            sub_type = ""
            matching_param_sub_type = re.search("(<\w+>)", main_type)

            if (matching_param_sub_type != None):
                main_type = main_type.replace(matching_param_sub_type.group(0), "")
                sub_type = matching_param_sub_type.group(0).replace("<", "").replace(">", "")
                if sub_type in type_matching_dict:
                    sub_type = update_type_for_import(sub_type)

            if main_type in type_matching_dict:
                main_type = update_type_for_import(main_type)
            
            # replace param.type altogether
            param.type = main_type if sub_type == "" else f"{main_type}<{sub_type}>"
        
        # ====================================================================================================
        # check the type of the return type
        main_return_type = method.return_type
        sub_return_type = ""
        match_sub_return_type = re.search("(<\w+>)", main_return_type)

        if (match_sub_return_type != None):
            main_return_type = main_return_type.replace(match_sub_return_type.group(0), "")
            sub_return_type = match_sub_return_type.group(0).replace("<", "").replace(">", "")
            if (sub_return_type in type_matching_dict):
                sub_return_type = update_type_for_import(sub_return_type)

        if main_return_type in type_matching_dict:
            main_return_type = update_type_for_import(main_return_type)
        
        method.return_type = main_return_type if sub_return_type == "" else f"{main_return_type}<{sub_return_type}>"

    return Template(data, "\n".join(list(import_statements)))

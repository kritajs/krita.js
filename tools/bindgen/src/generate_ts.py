from cxxheaderparser.simple import ClassScope, ParsedData

INDENT = "    "

# ==================================================================================

# logic for import is to search through the same parent folder to see if that file exists
# if it does exist, add that file reference statement with the path
# we will ignore all includes for now

def Template(
    classes: str,
) -> str:
    content: list[str] = []
    if classes != "":
        content.append(classes)
    return f"""// This file is automatically generated by bindgen. DO NOT EDIT.

// Some libkis classes depend on QtGlobal typedefs so we just include it in every header for convenience
// All includes are currently being ignored

// Instead of determining which forward declarations we need on a per-file basis, just forward declare
// everything we might need.

{classes}"""

# ==================================================================================

def Class(c: ClassScope) -> tuple[str, set[str]]:
    base_class_includes: set[str] = set()

    # Extract base classes
    bases: list[str] = []
    for base in c.class_decl.bases:
        base_name = base.typename.format()
        # If it's a base class, then we MUST add its #include. Base classes cannot be forward declared.
        base_class_includes.add(base_name)
        bases.append(base.access + " " + base_name)

    # Construct class declaration
    class_decl = c.class_decl.typename.format()
    if (len(bases)):
        class_decl += f" : {', '.join(bases)}"

    # Extract methods. Skip private methods.
    public_methods: list[str] = []
    protected_methods: list[str] = []
    for method in c.methods:
        # Skip constructors, destructors and operator overloads
        if method.constructor or method.destructor or method.operator is not None:
            continue

        return_type = method.return_type.format()
        name = method.name.format()
        params = ", ".join(map(lambda param: param.format(), method.parameters))
        method_decl = INDENT
        if method.static:
            method_decl += "static "
        method_decl += f"{return_type} {name}({params})"
        if method.const:
            method_decl += " const"
        method_decl += ";"

        if method.access == "public":
            public_methods.append(method_decl)
        elif method.access == 'protected':
            protected_methods.append(method_decl)

    public = "\n".join(public_methods)
    protected = "\n".join(protected_methods)

    output = f"""{class_decl}
{{
public:
{public}

{"protected:" if len(protected_methods) else ""}
{protected}
}};
"""

    return (output, base_class_includes)


# ==================================================================================
# Add mapping between types:
# existing js types - number, string, boolean
# if there is no matching type, check the rest of the files to see if you can find an export with the same name
# if not, then print it out into the console
type_matching_dict = {
    "qreal": "number",
    "bool": "boolean",
    "void": "void",
    "qint8": "number",
    "qint16": "number",
    "qint32": "number",
    "qint64": "number",
    "qintptr": "number",
    "qlonglong": "number",
    "qptrdiff": "number",
    "qsizetype": "number",
    "quint8" : "number",
    "quint16": "number",
    "quint32": "number",
    "quint64": "number",
    "quintptr": "number",
    "qulonglong": "number",
    "uchar": "string",
    "uint": "number",
    "ulong": "number",
    "ushort": "number"
}
# ==================================================================================

def generate_ts(data: ParsedData) -> str:
    # Keep any existing forward declarations
    forward_decls: set[str] = set()
    for forward_decl in data.namespace.forward_decls:
        forward_decls.add(forward_decl.typename.format())

    # Parse classes
    classes: list[str] = []
    base_class_includes: set[str] = set()
    for c in data.namespace.classes:
        (output, _base_class_includes) = Class(c)
        base_class_includes = _base_class_includes
        classes.append(output)

    # Format includes. Note that we only add includes for base classes.
    # Everything else can be forward declared.
    # includes: set[str] = set()
    # for include in base_class_includes:
    #     # Use angle brackets for Qt includes
    #     if include.startswith("Q"):
    #         includes.add(f"#include <{include}>")
    #     else:
    #         includes.add(f"#include \"{include}.h\"")

    return Template("\n".join(classes))

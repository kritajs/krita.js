from cxxheaderparser.simple import ClassScope, ParsedData
from TS_Class import TS_Ready_Class

INDENT = "    "

# ==================================================================================

# logic for import is to search through the same parent folder to see if that file exists
# if it does exist, add that file reference statement with the path
# we will ignore all includes for now

def Template(
    ts_class: TS_Ready_Class,
    import_statements: str,
) -> str:

    return f"""// This file is automatically generated by bindgen. DO NOT EDIT.

// Some libkis classes depend on QtGlobal typedefs so we just include it in every header for convenience
// All includes are currently being ignored

// Instead of determining which forward declarations we need on a per-file basis, just forward declare
// everything we might need.

{import_statements}

export as namespace {ts_class.name}

export = {ts_class.name}

{ts_class}
"""

# ==================================================================================
# Add mapping between types:
# existing js types - number, string, boolean
# if there is no matching type, check the rest of the files to see if you can find an export with the same name
# if not, then print it out into the console
# ==================================================================================

def generate_ts(data: TS_Ready_Class, type_matching_dict: dict[str, list[str]]) -> str:
    import_statements : set[str] = set() 
    # if the ts_ready_class has any params or return types that match the type_matching_dict
    # replace the string with the value and add import statement location if there is one
    for method in data.methods:
        # check the type of the param
        for param in method.params:
            if param.type in type_matching_dict:
                # replace the value type with the equivalent in ts
                matching_entry = type_matching_dict[param.type]
                param.type = matching_entry[0]
                if (matching_entry[1] != ""): # matching_entry[1] is the location of the file to import from
                    import_statements.add(f"import {param.type} from \"./{param.type}\";")
    
        # check the type of the output
        if method.return_type in type_matching_dict:
            method.return_type = type_matching_dict[method.return_type][0]
    print(import_statements)
    
    return Template(data, "\n".join(list(import_statements)))

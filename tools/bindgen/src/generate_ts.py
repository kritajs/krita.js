from cxxheaderparser.simple import ClassScope, ParsedData
from TS_Class import TS_Ready_Class

INDENT = "    "

# ==================================================================================

# logic for import is to search through the same parent folder to see if that file exists
# if it does exist, add that file reference statement with the path
# we will ignore all includes for now

def Template(
    ts_class: TS_Ready_Class,
    import_statements: str,
) -> str:

    return f"""// This file is automatically generated by bindgen. DO NOT EDIT.

// Some libkis classes depend on QtGlobal typedefs so we just include it in every header for convenience
// All includes are currently being ignored

// Instead of determining which forward declarations we need on a per-file basis, just forward declare
// everything we might need.

{import_statements}

export as namespace {ts_class.name}

export = {ts_class.name}

{ts_class}
"""

# ==================================================================================
# Add mapping between types:
# existing js types - number, string, boolean
# if there is no matching type, check the rest of the files to see if you can find an export with the same name
# if not, then print it out into the console
# ==================================================================================

def generate_ts(data: TS_Ready_Class, type_matching_dict: dict[str, list[str]]) -> str:
    import_statements : set[str] = set() 
    # if the ts_ready_class has any params or return types that match the type_matching_dict
    # replace the string with the value and add import statement location if there is one
    # except itself

    def add_import_statements(type_to_check: str, obj: object):
        matching_entry = type_matching_dict[getattr(obj, type_to_check)]
        setattr(obj, type_to_check, matching_entry[0])
        if (matching_entry[1] != "" and getattr(obj, type_to_check) != data.name): # matching_entry[1] is the location of the file to import from
            import_statements.add(f"import {getattr(obj, type_to_check)} from \"./{getattr(obj, type_to_check)}\";")

    for method in data.methods:
        # check the type of the param
        for param in method.params:
            if param.type in type_matching_dict:
                add_import_statements("type", param)
    
        # check the type of the return type
        if method.return_type in type_matching_dict:
            add_import_statements("return_type", method)

    print(import_statements)
    
    return Template(data, "\n".join(list(import_statements)))

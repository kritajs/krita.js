import { Method } from "./method";
import { isValidTsType } from "./type";

export function toClassString(name: string, methods: Method[]): string {
  const imports: string[] = [];
  const usedTypes: Set<string> = new Set();
  const kritajsImports: Set<string> = new Set(["Id", "invoke"]);
  const methodStrings: string[] = [];
  
  for (const m of methods) {
    if (m.static) {
      kritajsImports.add("invokeStatic");
    }

    // Construct method body
    let body = "";
    if (m.return) body += " return ";
    body += `${m.static ? "invokeStatic" : "invoke"}`;
    const id = `${m.static ? "this.__className__" : "this.__id__"}`;
    // Parameters
    body += `(${id}, "${m.name}"`;
    if (m.parameters.length > 0) {
      body += `, [${m.parameters.map(p => p.name).join(", ")}]`;
    }
    body += ")";
    methodStrings.push(m.toString(body));

    // Collect all the types used in this class. Used later to figure out which
    // imports this class needs.
    if (m.return) {
      const types = Array.isArray(m.return.name) ? m.return.name : [m.return.name];
      for (const t of types) {
        usedTypes.add(t);
      }
    }
    for (const p of m.parameters) {
      const types = Array.isArray(p.type.name) ? p.type.name : [p.type.name];
      for (const t of types) {
        usedTypes.add(t);
      }
    }
  }

  // Figure out which types need to be imports. Skip importing if the type:
  // - is the current class
  // - resolves to a primitive type
  // - starts with the letter Q
  for (const type of usedTypes) {
    if (type === name || isValidTsType(type) || type.startsWith("Q")) continue;
    imports.push(type);
  }

  return `// This file is auto-generated by bindgen. DO NOT EDIT.
import { ${Array.from(kritajsImports)} } from "./kritajs";
${imports.sort().map(i => `import { ${i} } from "./${i}";`).join("\n")}

export class ${name} {
  private static readonly __className__ = "${name}";

  private constructor(private readonly __id__: Id) {}

${methodStrings.join("\n\n")}
}
`;
}
